<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unity | naonya3.me]]></title>
  <link href="http://naonya3.me/blog/categories/unity/atom.xml" rel="self"/>
  <link href="http://naonya3.me/"/>
  <updated>2014-07-14T18:34:38+09:00</updated>
  <id>http://naonya3.me/</id>
  <author>
    <name><![CDATA[にょす(@naonya3)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Unity入門記録03]]></title>
    <link href="http://naonya3.me/blog/2014/02/15/unity-practice03/"/>
    <updated>2014-02-15T22:03:29+09:00</updated>
    <id>http://naonya3.me/blog/2014/02/15/unity-practice03</id>
    <content type="html"><![CDATA[<h2>ブロック崩しを仕上げる</h2>

<p>前回に引き続きブロック崩しを進める。
今回はゲームクリアと、ゲームオーバーを実装する。</p>

<h2>ゲームオーバーの実装</h2>

<p>簡単そうなのでこちらから。</p>

<p>これは前回と同じように当たり判定<code>OnCollisionEnter</code>を使い、下のバーとの当たり判定を見ればいい。</p>

<p>下のバーのGameObjectを取得できればほぼ終わり。</p>

<p>GameObjectを取得する方法でとりあえず知っているのは<code>Find</code>を使う方法だけなので、Hierarchyパネルで下のバーに一意な名前をつけて取得しやすくする。</p>

<p><code>BottomBar</code>という名前をつけた。</p>

<p><img src="https://copy.com/thumbs_public/pd7IZyLqN9dK/BottomBar.png?revision=45&amp;size=512" alt="BottomBar" /></p>

<p>ゲームオーバー画面は後で作るとして、ひとまず「ボールを消す」ということでゲームオーバーを表現した。</p>

<p>コードはこんな感じで、BallController内に実装した。</p>

<p>```
function OnCollisionEnter(col:Collision) {</p>

<pre><code>var blocks = GameObject.Find("Blocks");
if (col.transform.IsChildOf(blocks.transform)) {
    Destroy(col.gameObject);
}

var bottomBar = GameObject.Find("BottomBar");
if (col.gameObject == bottomBar) {
    Debug.Log("Game Over");
    Destroy(this.gameObject);
}
</code></pre>

<p>}
```</p>

<p>BallControllerにゲームオーバー処理などを書いていくのは、プログラムの規模が大きくなると良くないことが起きるのは容易に想像できるが、今回は気にしないでおく。</p>

<h2>ゲームクリアの実装</h2>

<p>ブロック崩しは、ブロックがなくなったらクリアだ。</p>

<p>すべてのブロックは<code>Blocks</code>の子にしてあるので、<code>Blocks</code>の子が<code>0</code>になったらクリアでいいだろう。</p>

<p>子の数え方がわからないので調べる。</p>

<p>前回の経験上、子関係のものは<code>Transform</code>にありそうなので、ドキュメントの<code>Transform</code>の項を眺めてたらベストなプロパティがあった。</p>

<p><a href="https://docs.unity3d.com/Documentation/ScriptReference/Transform-childCount.html">Transform.childCount</a></p>

<p>これでできそうだ。</p>

<p>```
function OnCollisionEnter(col:Collision) {</p>

<pre><code>var blocks = GameObject.Find("Blocks");
if (col.transform.IsChildOf(blocks.transform)) {
    Destroy(col.gameObject);

    // Check Count of Balls.
    if (blocks.transform.childCount == 0) {
        Debug.Log("Clear!!");
        Destroy(this.gameObject);   
    }
}

var bottomBar = GameObject.Find("BottomBar");
if (col.gameObject == bottomBar) {
    Debug.Log("Game Over");
    Destroy(this.gameObject);
}
</code></pre>

<p>}
```</p>

<p>ブロックとの当たり判定の中で残りのブロック数をチェックして<code>0</code>ならクリアだ。</p>

<p>先ほどと同様に、ボールを消すことでクリアとした。</p>

<p><strong>だが、これではダメだった。</strong></p>

<p><code>Destroy()</code>の直後はまだ実際にオブジェクトは削除されていないようで、カウントが減らなかった。</p>

<p>ドキュメントを読んでみるとしっかりと書いてあった。</p>

<p><a href="https://docs.unity3d.com/Documentation/ScriptReference/Object.Destroy.html">Object.Destroy</a></p>

<blockquote><p>Actual object destruction is always delayed until after the current Update loop</p></blockquote>

<p>ということ毎ループ、ブロックの残りの数を数えることにした。</p>

<p>ブロック崩し位なら対して影響なさそうだが、本当はあまり無駄な処理を毎ループ行うべきではない。</p>

<p>毎ループ処理をしたいときは、<code>Update()</code>の中に処理を書けば良い。</p>

<p>```</p>

<h1>pragma strict</h1>

<p>var speed = 5;</p>

<p>function Start () {</p>

<pre><code>rigidbody.AddForce((transform.forward + transform.right) * speed, ForceMode.VelocityChange);
</code></pre>

<p>}</p>

<p>function Update () {</p>

<pre><code>var blocks = GameObject.Find("Blocks");

// Check count of remaining blocks.
if (blocks.transform.childCount == 0) {
        Debug.Log("Clear!!");
        Destroy(this.gameObject);   
}
</code></pre>

<p>}</p>

<p>function OnCollisionEnter(col:Collision) {</p>

<pre><code>var blocks = GameObject.Find("Blocks");
if (col.transform.IsChildOf(blocks.transform)) {
    Destroy(col.gameObject);
}

var bottomBar = GameObject.Find("BottomBar");
if (col.gameObject == bottomBar) {
    Debug.Log("Game Over");
    Destroy(this.gameObject);
}
</code></pre>

<p>}
```</p>

<h2>とりあえず遊べる感じになった</h2>

<p><a href="/contents/unity/practice03/">Unity WebPlayerが必要です</a></p>

<h2>まとめ</h2>

<p>少しわかってきたので、ドキュメントを眺めるようにしよう。</p>

<p>次回は、シーン遷移をやってみたいので、シーン遷移させてゲームクリアの画面を表示させるようにする。</p>

<p>ソースコードは<a href="https://github.com/naonya3/Unity-Breakout">github</a></p>

<p>tagは<code>practice03</code>です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unity入門記録 02]]></title>
    <link href="http://naonya3.me/blog/2014/02/15/unity-practice02/"/>
    <updated>2014-02-15T04:22:33+09:00</updated>
    <id>http://naonya3.me/blog/2014/02/15/unity-practice02</id>
    <content type="html"><![CDATA[<h2>ブロック崩しの続き</h2>

<p>前回から引き続きチュートリアルのブロック崩しを作っていきます。</p>

<p>ただ、本家のチュートリアルの続きが無いので自分で考えながらです。（日本語しか見てないので、英語版は用意されているのかもしれませんが）</p>

<h2>まずはブロックの用意</h2>

<p>前回の成果物に圧倒的に足りないもの。</p>

<p>そう、<strong>ブロック</strong>。</p>

<p>壁を作ったのと同様にしていけば問題ないでしょう。</p>

<p><img src="https://copy.com/thumbs_public/YQo29juAMwsk/block.png?revision=43&amp;size=512" alt="Blocks" /></p>

<p>こんな感じで配置していきます。</p>

<p>これだけで、ボールはブロックに跳ねるようになります。</p>

<p>各ブロックは、Empty Objectを作ってそこに入れていくと管理しやすいでしょう。</p>

<p>Empty Objectはフォルダみたいなものでしょうか。AfterEffectやっている人はNullObjectの概念が非常に近い感じです。</p>

<p>AS3やObjective-C、JS（DOM）だとそれぞれSprite, UIView, divみたいなものを意識するといいかもしれません。</p>

<p>これだけではブロックは消えたりしないので、ボールとの当たり判定を見て自分でブロックを消す必要がありそうです。</p>

<p>Unityにおいての当たり判定の取り方を調べれは良さそうです。</p>

<h2>オブジェクト同士の当たり判定を取る</h2>

<p>調べてみると、オブジェクト同士が衝突した際に、<code>Rigidbody</code>(前回ボールに設定した)の<code>OnCollisionEnter(col : Collision)</code>メソッドが呼ばれるらしいです。</p>

<p>Unityの<code>Collision</code>オブジェクトというのがわからないので調べてみると、衝突という意味みたいです。そのままですね。</p>

<p>Collisionには衝突の情報として、衝突対象の<code>GameObject</code>が格納されてるっぽいので、そのオブジェクトを<code>OnCollisionEnter</code>の中で削除すれば良さそうです。</p>

<p>オブジェクトの削除方法も調べてみました。</p>

<p><code>Destroy(GameObject)</code>というメソッドを使えばいいっぽいです。</p>

<p>まとめると</p>

<p>```
function OnCollisionEnter(col:Collision) {</p>

<pre><code>Destroy(col.gameObject);
</code></pre>

<p>}
```</p>

<p>でしょう。</p>

<p>これを前回のBallControllerに追加してみることに。</p>

<p>```</p>

<h1>pragma strict</h1>

<p>var speed = 5;</p>

<p>function Start () {</p>

<pre><code>rigidbody.AddForce((transform.forward + transform.right) * speed, ForceMode.VelocityChange);
</code></pre>

<p>}</p>

<p>function Update () {</p>

<p>}</p>

<p>function OnCollisionEnter(col:Collision) {</p>

<pre><code>Destroy(col.gameObject);
</code></pre>

<p>}
```
これがコード全体です。実行してみます。</p>

<p><a href="/contents/unity/practice02/01.html">Unity WebPlayerが必要です。</a></p>

<p><strong>おしい。</strong></p>

<p>このままだと無差別殺人なので、当たった対象がブロックかどうか調べる必要がありそうです。</p>

<h2>オブジェクトを見分ける</h2>

<p>どうやってオブジェクトを見分けるか考えてみました。</p>

<p><code>col.gameObject.name</code>でhierarchyパネル上でつけた名前が取得できることはわかったので、ブロック全部に同じ名前をつけてそれで判別してもいいのですが、ブロックなどの当たり判定対象が増えてきた時に大変な事になりそうです。</p>

<p>今回ブロックはすべて<code>Blocks</code>という名前をつけたEmptyObjectに入れたので
<code>col.gameObject</code>が<code>Blocks</code>の子かどうか知る方法はないか調べてみることに。</p>

<p><code>(gameObject).transform.IsChildOf(gameObject)</code>というメソッドがあったので、多分これが使えます。</p>

<p>なんでtransformに子を調べたりするメソッドが入っているのかよくわかりません。ドキュメントを後で読んできます。</p>

<p>とりあえず今回は、<code>Blocks.transform.IsChildOf(col.gameObject)</code>で衝突したオブジェクトが<code>Blocks</code>の子かどうか分かりそうです。</p>

<p><strong>が、実際はこのコードダメだった</strong></p>

<p><code>is child Of hoge</code>なので<code>hogeの子ですか？</code>って意味のメソッドぽくて、</p>

<p><code>
col.gameObject.transform.IsChildOf(Blocks);
</code></p>

<p>が正解。</p>

<p>肝心の<code>Blocks</code>オブジェクトの取得方法ですが、<code>GameObject.Find</code>という関数を使えば実現できそうです。</p>

<p>今回はhierarchy直下に<code>Blocks</code>を配置しているので、</p>

<p><code>
var blocks = GameObject.Find('/root/Blocks');
</code></p>

<p>で取得できるはずです。</p>

<p>と、思ったんだけど<strong>できませんでした。</strong></p>

<p><code>/root</code> から辿れるって書いてある気がするんだけど、取得できませんでした。勘違いしてるみたいです。</p>

<p>GameObjectのたどり方は結構重要そうな気がするので、調べがいがありそう。</p>

<p>結局</p>

<p><code>
var blocks = GameObject.Find('Blocks');
</code></p>

<p>で、取得出来ました。納得はしていない。</p>

<p>ということで、全体のコードが以下です。</p>

<p>```</p>

<h1>pragma strict</h1>

<p>var speed = 5;</p>

<p>function Start () {</p>

<pre><code>rigidbody.AddForce((transform.forward + transform.right) * speed, ForceMode.VelocityChange);
</code></pre>

<p>}</p>

<p>function Update () {</p>

<p>}</p>

<p>function OnCollisionEnter(col:Collision) {</p>

<pre><code>var blocks = gameObject.Find("Blocks");
if (col.transform.IsChildOf(blocks.transform)) {
    Destroy(col.gameObject);
}
</code></pre>

<p>}
```</p>

<p>これをビルドすると以下のようになります。</p>

<p><img src="https://copy.com/thumbs_public/huNJgmpm8jYe/game.png?revision=44&amp;size=512" alt="game" /></p>

<p><a href="/contents/unity/practice02/02.html">Unity WebPlayerが必要です。</a></p>

<p>あと少しで完成しそうですが、疲れたので次にします。</p>

<p>今回のソースも<a href="https://github.com/naonya3/Unity-Breakout">github</a>にあげてあります。</p>

<p><code>practice02</code>タグを見て下さい。</p>

<h2>ゲームオーバーはどうする？</h2>

<p>同じように、枠の下側のCubeとの当たり判定を見ればいいでしょう。</p>

<h2>ゲームクリアはどうする？</h2>

<p><code>Blocks</code>の子が<code>0</code>になったらゲームクリアにできそう。</p>

<p>そのあと、ボールを止めたりシーンを遷移させたりすると完成かも。</p>

<h2>今回のまとめと所感</h2>

<ul>
<li>GameObjectの取得は重要そうだ</li>
<li>Ballが他のObjectを操作するのはイケてない感じがする</li>
<li>プログラミング作法的な話は後でいいや</li>
<li>JSで書いてるっぽいけど、他の言語使えたよね？？？</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unity入門記録 01]]></title>
    <link href="http://naonya3.me/blog/2014/02/03/unity-practice01/"/>
    <updated>2014-02-03T01:30:44+09:00</updated>
    <id>http://naonya3.me/blog/2014/02/03/unity-practice01</id>
    <content type="html"><![CDATA[<p>iPhoneプログラマーとして2年間Objective-Cを書いて、その前にFlashを2年。</p>

<p>Unity4.3から2Dゲームも作りやすくなったということなので、趣味ではじめてみようかと。</p>

<p>全く事前知識がないので、初心者の記録として晒しておきます。</p>

<p>途中で飽きてやめたらごめんなさい。</p>

<h2>ダウンロード</h2>

<p>ここからダウンロード。</p>

<p><a href="http://japan.unity3d.com/unity/download/">http://japan.unity3d.com/unity/download/</a></p>

<p>ちなみに初心者なので無料版で十分（なはず）。</p>

<p>iPhone/Androidにも無料で書き出せるようになったのは制作モチベーション上がる。</p>

<h2>起動</h2>

<p>サンプルと思われる、すごいゲーム出てきた。</p>

<p><img src="https://copy.com/thumbs_public/6TU12KARC8ex/startup.png?revision=42&amp;size=512" alt="screenshot" /></p>

<p>パネルたくさんファイルたくさんで、何したらいいか全くわからん。</p>

<p>見た目で挫折しそう。</p>

<h2>チュートリアルあった</h2>

<p>本家にドキュメントとチュートリアルがあった。</p>

<p><a href="http://japan.unity3d.com/developer/document/">http://japan.unity3d.com/developer/document/</a></p>

<p>このチュートリアルをとりあえずやってみる。</p>

<p><a href="http://japan.unity3d.com/developer/document/tutorial/my-first-unity/">http://japan.unity3d.com/developer/document/tutorial/my-first-unity/</a></p>

<p>ブロック崩しが作れるらしい。</p>

<h2>一応出来た</h2>

<p><a href="http://naonya3.me/contents/unity/practice01/" target="_blank"><strong>Unity Web Playerが必要です。</strong></a></p>

<h2>iPhone用に書き出す</h2>

<p>せっかくなのでiPhoneで動作させたい。</p>

<p>File > Build Settingからできる。</p>

<p>あとはXcodeプロジェクトが作られるので、開いてビルドすればいいだけ。</p>

<p>ココらへんはUnityというよりiPhone開発の話なので必要ならググるとわかる。</p>

<p><strong>しかし、チュートリアルのままだとiPhone上でキー入力のInputがないので、ラケットの操作ができない。</strong></p>

<p>多分マウス入力の値を見るようにすれば、タッチ座標に変換されるはずなので、</p>

<p>チュートリアルのラケットに対応するスクリプトの</p>

<p>```
function Update () {</p>

<pre><code>rigidbody.AddForce(transform.right * Input.GetAxisRaw("Horizontal") * Accel, ForceMode.Impulse);
</code></pre>

<p>}
```</p>

<p>この<code>Horizontal</code>の部分を<code>Mouse X</code>に変更した。</p>

<p>```
function Update () {</p>

<pre><code>rigidbody.AddForce(transform.right * Input.GetAxisRaw("Mouse X") * Accel, ForceMode.Impulse);
</code></pre>

<p>}
```</p>

<p><code>Mouse X</code>という値はInput Manager(Edit > Project Settings > Input > inspectorパネル)をみるとわかる。</p>

<p><img src="https://copy.com/thumbs_public/JOIaUGoJS4O1/screenshot.png?revision=41&amp;size=512" alt="screenshot" /></p>

<p>こちらは、実機のスクリーンショットです。</p>

<p>見切れてるし、微妙な操作感だけど簡単に動かすことができた。</p>

<h2>今日のまとめ</h2>

<p>ファイル一式を<a href="https://github.com/naonya3/Unity-Breakout/tree/practice01">Github</a>に置いておく。この記事に対応するバージョンは<code>practice01</code>という名前でタグが切ってある。</p>

<p>Unityのインストール時間を除けばだいたい１時間あればここまで出来る。</p>

<p>まずはプログラミング能力より、Unityというアプリケーションの操作に慣れる事と、何ができるのかを知る必要がありそう。</p>

<p>ともあれ、Unity入門は簡単だったので時間あったらやってみると楽しいと思う。</p>

<p>チュートリアルの次回分がなくなった(2014.2.2現在)
ので、このあとは自分でブロック崩しを実装する必要がある。</p>

<p>当たり判定の取り方がわかれば、多分すぐ出来るはず。</p>
]]></content>
  </entry>
  
</feed>
